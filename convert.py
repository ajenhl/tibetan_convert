#!/usr/bin/env python3

"""Script to split Tibetan corpus Word XML files into multiple files,
one per text, each filename being a Derge reference number (where
there is ambiguity, a meaningless unique identifier is used). The
content is converted into TEI XML in the format expected by TACL."""

import argparse
import logging
import os
import re

from lxml import etree

import tacl
# Autogenerated mapping of reference number to title.
from mapping import MAPPING

SIMPLIFY_DUL_BA_WORD_XSLT = """<?xml version="1.0"?>
<xsl:stylesheet exclude-result-prefixes="w" version="1.0"
                xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:key name="text-key"
           match="//w:*[preceding-sibling::w:p[w:pPr/w:pStyle/@w:val='P13' or
                                               w:pPr/w:pStyle/@w:val='P14' or
                                               w:pPr/w:pStyle/@w:val='P15']]"
           use="preceding-sibling::w:p[w:pPr/w:pStyle/@w:val='P13' or
                                       w:pPr/w:pStyle/@w:val='P14' or
                                       w:pPr/w:pStyle/@w:val='P15'][1]" />

  <xsl:template match="/">
    <!-- Structure primarily by text. -->
    <texts>
      <xsl:apply-templates select="//w:p[w:pPr/w:pStyle/@w:val='P13' or
                                         w:pPr/w:pStyle/@w:val='P14' or
                                         w:pPr/w:pStyle/@w:val='P15']"
                           mode="text" />
    </texts>
  </xsl:template>

  <!-- Text start. -->
  <xsl:template match="w:p" mode="text">
    <text>
      <title>
        <xsl:value-of select="normalize-space(w:r/w:t)" />
      </title>
      <xsl:apply-templates select="key('text-key', .)" />
    </text>
  </xsl:template>

  <!-- Text-title elements that are caught in the key. -->
  <xsl:template match="w:p[w:pPr/w:pStyle/@w:val='P13' or
                           w:pPr/w:pStyle/@w:val='P14' or
                           w:pPr/w:pStyle/@w:val='P15']" />

  <!-- Volume. -->
  <xsl:template match="w:p[w:pPr/w:pStyle/@w:val='P10' or
                           w:pPr/w:pStyle/@w:val='P11' or
                           w:pPr/w:pStyle/@w:val='P12']">
    <volume n="{normalize-space(w:r/w:t)}" />
  </xsl:template>

  <xsl:template match="w:p">
    <p>
      <xsl:apply-templates select="w:r/w:t" />
    </p>
  </xsl:template>

  <xsl:template match="w:*">
    <xsl:if test="normalize-space(w:r/w:t)">
      <unknown>
        <xsl:apply-templates select="w:r/w:t" />
      </unknown>
    </xsl:if>
  </xsl:template>

  <xsl:template match="w:t">
    <xsl:apply-templates />
  </xsl:template>

</xsl:stylesheet>"""

SIMPLIFY_MDO_SDE_WORD_XSLT = """<?xml version="1.0"?>
<xsl:stylesheet exclude-result-prefixes="w" version="1.0"
                xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:template match="/">
    <!-- Structure primarily by text. -->
    <texts>
      <xsl:apply-templates select="//w:p[w:pPr/w:pStyle/@w:val='Heading4']"
                           mode="text" />
    </texts>
  </xsl:template>

  <!-- Text start. -->
  <xsl:template match="w:p" mode="text">
    <text>
      <xsl:if test="preceding-sibling::*[1]/w:pPr/w:pStyle/@w:val='Heading3'">
        <xsl:attribute name="id">
          <xsl:value-of select="normalize-space(preceding-sibling::*[1]/w:r/w:t)" />
        </xsl:attribute>
      </xsl:if>
      <title>
        <xsl:value-of select="normalize-space(w:r/w:t)" />
      </title>
      <xsl:apply-templates select="preceding-sibling::w:p[w:pPr/w:pStyle/@w:val='Heading2'][1]" />
      <xsl:apply-templates select="following-sibling::w:p[preceding-sibling::w:p[w:pPr/w:pStyle/@w:val='Heading4'][1]=current()]" />
    </text>
  </xsl:template>

  <!-- Text-title elements that are caught in the key. -->
  <xsl:template match="w:p[w:pPr/w:pStyle/@w:val='Heading4']" />

  <!-- Text identifier elements. -->
  <xsl:template match="w:p[w:pPr/w:pStyle/@w:val='Heading3']" />

  <!-- Volume. -->
  <xsl:template match="w:p[w:pPr/w:pStyle/@w:val='Heading2']">
    <volume n="{normalize-space(w:r/w:t)}" />
  </xsl:template>

  <xsl:template match="w:p">
    <p>
      <xsl:apply-templates select="w:r/w:t" />
    </p>
  </xsl:template>

  <xsl:template match="w:*">
    <xsl:if test="normalize-space(w:r/w:t)">
      <unknown>
        <xsl:apply-templates select="w:r/w:t" />
      </unknown>
    </xsl:if>
  </xsl:template>

  <xsl:template match="w:t">
    <xsl:apply-templates />
  </xsl:template>

</xsl:stylesheet>"""

PROMOTE_VOLUME_XSLT = """<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:template match="text">
    <xsl:copy>
      <xsl:apply-templates select="@*" />
      <xsl:apply-templates select="title" />
      <!-- If the first element after the title is not a milestone,
           use the previous milestone to determine the volume. -->
      <xsl:if test="local-name(title/following-sibling::*[1]) != 'volume'">
        <xsl:if test="preceding::volume">
          <volume n="{preceding::volume[1]/@n}">
            <xsl:apply-templates select="*[not(local-name()='title')][preceding::volume=current()/preceding::volume]" />
          </volume>
        </xsl:if>
      </xsl:if>
      <xsl:apply-templates select="volume" />
    </xsl:copy>
  </xsl:template>

  <xsl:template match="volume">
    <xsl:copy>
      <xsl:apply-templates select="@*" />
      <xsl:apply-templates select="following-sibling::*[not(local-name()='volume')][preceding-sibling::volume[1]=current()]" />
    </xsl:copy>
  </xsl:template>

  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
  </xsl:template>

</xsl:stylesheet>"""

TO_TEI_XSLT = """<?xml version="1.0"?>
<xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:template match="text">
    <TEI.2>
      <xsl:apply-templates select="@id" />
      <teiHeader>
        <fileDesc>
          <titleStmt>
            <title><xsl:value-of select="title" /></title>
          </titleStmt>
          <sourceDesc>
            <bibl />
          </sourceDesc>
        </fileDesc>
        <encodingDesc>
          <projectDesc>
            <p>Text as provided by Ulrich Pagel. TEI markup by Jamie Norrish, in imitation of the markup used for the CBETA texts.</p>
          </projectDesc>
        </encodingDesc>
      </teiHeader>
      <text>
        <body>
          <xsl:apply-templates />
        </body>
      </text>
    </TEI.2>
  </xsl:template>

  <xsl:template match="volume">
    <div n="{@n}" type="volume">
      <p><xsl:apply-templates /></p>
    </div>
  </xsl:template>

  <xsl:template match="p">
    <xsl:apply-templates />
  </xsl:template>

  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
  </xsl:template>

</xsl:stylesheet>"""

# Relative to TEI.2
TEI_TITLE_XPATH = 'teiHeader/fileDesc/titleStmt/title/text()'

SOURCE_DIR = 'source'
DUL_BA_FILENAME = "'Dul ba Pagel.docx"
DUL_BA_MAPPING_EXCEPTIONS = {
    "so sor thar pa'i mdo": 'D2',
    "dge slong ma'i so sor thar pa'i mdo": 'D4',
    }

MDO_SDE_FILENAME = "mDo sde, vol. 1-32, Pagel.xml"


def main ():
    parser = generate_parser()
    args = parser.parse_args()
    configure_logging(args.verbose)
    split_files(args)

def configure_logging (verbose):
    """Configures the logging used."""
    if not verbose:
        log_level = logging.WARNING
    elif verbose == 1:
        log_level = logging.INFO
    else:
        log_level = logging.DEBUG
    logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s',
                        level=log_level)

def fix_mdo_sde (tree):
    bad_volume = tree.xpath('//w:p[normalize-space(w:r/w:t)="Volume wa (20)"]/w:pPr/w:pStyle',
                            namespaces={'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'})[0]
    bad_volume.set('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}val', 'Heading2')
    bad_id = tree.xpath('//w:t[text() = "KtD0226-"]',
                        namespaces={'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'})[0]
    bad_id.text = 'KtD0226'
    return tree

def generate_parser ():
    parser = argparse.ArgumentParser()
    parser.add_argument('-v', '--verbose', action='count',
                        help=tacl.constants.VERBOSE_HELP)
    parser.add_argument('output', metavar='OUTPUT',
                        help='Directory to output files to.')
    return parser

def output_text (output_dir, identifier, text):
    if identifier.startswith('missing'):
        identifier = 'M01n{}_001'.format(identifier[8:])
    else:
        identifier = 'D01n{}_001'.format(identifier[1:])
    output_path = os.path.join(output_dir, '{}.xml'.format(identifier))
    with open(output_path, 'w', encoding='utf-8') as output_fh:
        output_fh.write(etree.tostring(text, encoding='unicode',
                                       pretty_print=True))

def reverse_mapping (mapping):
    """Reverse `mapping` so that the keys are text titles and the values
    are identifiers.

    Handle the case of the same title having multiple identifiers by
    removing that title from the mapping entirely.

    Also handle altnerate titles that are given in the same title
    string.

    """
    logging.info('Generating mapping of titles to identifiers')
    new_mapping = {}
    duplicates = []
    for identifier, title in mapping.items():
        titles = split_title(title)
        for title_part in titles:
            if title_part in new_mapping:
                duplicates.append(title_part)
                del new_mapping[title_part]
            elif title_part not in duplicates:
                new_mapping[title_part] = identifier
    return new_mapping

def split_dul_ba (mapping, output_dir, count, seen):
    logging.info('Splitting {}'.format(DUL_BA_FILENAME))
    source_tree = etree.parse(os.path.join(SOURCE_DIR, DUL_BA_FILENAME))
    xslt_root = etree.XML(SIMPLIFY_DUL_BA_WORD_XSLT)
    transform = etree.XSLT(xslt_root)
    tree = transform_text(transform(source_tree))
    for text in tree.xpath('/texts/TEI.2'):
        title = ''.join(text.xpath(TEI_TITLE_XPATH)).strip()
        identifier = mapping.get(title, None)
        if identifier is None:
            # Special case some known cases.
            if title in DUL_BA_MAPPING_EXCEPTIONS:
                identifier = DUL_BA_MAPPING_EXCEPTIONS[title]
                logging.warn('Special casing title "{}" to identifier "{}"'.format(title, identifier))
            else:
                # Create a unique identifier.
                identifier = 'missing-{}'.format(count)
                count += 1
        if identifier in seen:
            logging.error('Overwriting file with identifier "{}"!'.format(
                identifier))
        seen.append(identifier)
        output_text(output_dir, identifier, text)
    return count, seen

def split_mdo_sde (mapping, output_dir, count, seen):
    logging.info('Splitting {}'.format(MDO_SDE_FILENAME))
    source_tree = fix_mdo_sde(etree.parse(
        os.path.join(SOURCE_DIR, MDO_SDE_FILENAME)))
    xslt_root = etree.XML(SIMPLIFY_MDO_SDE_WORD_XSLT)
    transform = etree.XSLT(xslt_root)
    tree = transform_text(transform(source_tree))
    for text in tree.xpath('/texts/TEI.2'):
        title = ''.join(text.xpath(TEI_TITLE_XPATH)).strip()
        identifier = mapping.get(title, None)
        if identifier is None:
            identifier = text.get('id')
            if identifier is not None:
                identifier = re.sub(r'^KtD0*(\d+[a-z]?)$', r'D\1', identifier)
                logging.info('Using identifier "{}" from text'.format(
                    identifier))
        if identifier is None:
            # Create a unique identifier.
            identifier = 'missing-{}'.format(count)
            count += 1
        if identifier in seen:
            new_identifier = '{}-{}'.format(identifier, count)
            logging.error('Identifier "{}" already used! Writing text using "{}"'.format(identifier, new_identifier))
            identifier = new_identifier
        seen.append(identifier)
        output_text(output_dir, identifier, text)
    return count, seen

def split_files (args):
    # Sadly each Word XML document is different, so handle them
    # separately.
    output_dir = os.path.abspath(args.output)
    if not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
        except OSError as err:
            logging.error('Could not create output directory: {}'.format(err))
            raise
    mapping = reverse_mapping(MAPPING)
    count = 1
    seen = []
    count, seen = split_dul_ba(mapping, output_dir, count, seen)
    count, seen = split_mdo_sde(mapping, output_dir, count, seen)

def split_title (title):
    titles = set()
    parts = title.split(' / ')
    for part in parts:
        part = part.strip()
        if '[' in part:
            # Add in a version without square brackets.
            titles.add(part.replace('[', '').replace(']', '').strip())
            # If the square brackets do not encompass the whole title
            # part, add in a version without the text contained by
            # square brackets.
            titles.add(re.sub(r'\[[^]]*\]', '', part).strip())
        titles.add(part)
    return list(titles)

def transform_text (tree):
    xslt_root = etree.XML(PROMOTE_VOLUME_XSLT)
    transform = etree.XSLT(xslt_root)
    text = etree.tostring(transform(tree).getroot(), encoding='unicode')
    text = re.sub(r'\[\s*\[(\d+[ab])\]\[(\d+[ab]\.?\d+)\]\s*\]',
                  r'[[\1]][[\2]]', text)
    text = re.sub(r'([^[])\[([^[])', r'\1[[\2', text)
    text = re.sub(r'([^]])\]([^]])', r'\1]]\2', text)
    text = re.sub(r'\[\[(\d+[ab])\]\]', r'<pb n="\1" />', text)
    text = re.sub(r'\[\[(\d+[ab]\.?\d+)\]\]', r'<lb n="\1" />', text)
    tree = etree.XML(text, etree.XMLParser(huge_tree=True))
    xslt_root = etree.XML(TO_TEI_XSLT)
    transform = etree.XSLT(xslt_root)
    return transform(tree)


if __name__ == '__main__':
    main()
